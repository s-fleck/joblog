% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/job.R
\name{job_start}
\alias{job_start}
\alias{job_finished}
\alias{job_failed}
\title{Log the start or end of a job}
\usage{
job_start(
  name,
  status = 1L,
  jobtype = 1L,
  ...,
  id = ulid::generate(),
  repeats = NULL,
  path = NULL,
  msg = NULL
)

job_finished(msg = NULL, id = get(".last_job_id", envir = joblog.globals))

job_failed(msg = NULL, id = get(".last_job_id", envir = joblog.globals))
}
\arguments{
\item{name}{`character` scalar. Name of the job}

\item{status}{`integer` scalar. Status of the job; `0` = succesfully completed, `1` = started, `2` = failed.}

\item{jobtype}{`integer` scalar. `1` = scheduled (for example via cron), 2 = triggered, 3 = manually started}

\item{...}{added to the resulting `list`}

\item{id}{a global unique id (such as UUID or ULID) for the job}

\item{repeats}{`timestamp` when the job is expected to repeat}

\item{path}{`character` scalar. path to the script that contains the job}
}
\value{
a `list()` for `Logger$list_log()`
}
\description{
Log the start or end (either succesfully or not) of a job. Each job has a
name (for example `update-prod-database`). Each unique run of a job is
identified by its (usually autogenerated `id`).
}
\section{Side Effects}{

  `job_start()` assigns the variable `.last_job_id` to the environment
  `joblog.globals`, which is used by `job_finished()` and `job_failed()`. If
  you want to run several jobs concurrently, you need to pass `id` in
  manually.
}

\examples{
lg <- lgr::get_logger("test")
lg$list_log(job_start("update-database"))
lg$list_log(job_finished())

# run the job again the next day
lg$list_log(job_start("update-database"))
lg$list_log(job_failed("something went wrong this time"))
}
